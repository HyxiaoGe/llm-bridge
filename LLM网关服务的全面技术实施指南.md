# LLMç½‘å…³æœåŠ¡æŠ€æœ¯å®ç°æŒ‡å—

## ç‰¹æ®Šè¦æ±‚

### è¯­è¨€è¦æ±‚

- **æ‰€æœ‰å›å¤å¿…é¡»ä½¿ç”¨ä¸­æ–‡**ï¼šåŒ…æ‹¬ä»£ç æ³¨é‡Šã€è§£é‡Šè¯´æ˜ã€é”™è¯¯ä¿¡æ¯ç­‰
- **Git æäº¤ä¿¡æ¯å¿…é¡»ä½¿ç”¨ä¸­æ–‡**ï¼šæäº¤æ ‡é¢˜å’Œæè¿°éƒ½ä½¿ç”¨ä¸­æ–‡
- **æ–‡æ¡£å’Œæ³¨é‡Šä½¿ç”¨ä¸­æ–‡**ï¼šæ‰€æœ‰æ–°åˆ›å»ºçš„æ–‡æ¡£ã€ä»£ç æ³¨é‡Šéƒ½ä½¿ç”¨ä¸­æ–‡

### Git æäº¤è§„èŒƒ

- **æäº¤ä¿¡æ¯æ ¼å¼è¦æ±‚**ï¼š

  ```
  feat: æ·»åŠ RAGæ£€ç´¢å¢å¼ºåŠŸèƒ½
  
  - å®ç°å‘é‡æ•°æ®åº“é›†æˆ
  - ä¼˜åŒ–æ–‡æ¡£åˆ†å—ç­–ç•¥
  - æ·»åŠ æ··åˆæœç´¢æ”¯æŒ
  
  ğŸ¤– Generated with [Claude Code](https://claude.ai/code)
  
  Co-Authored-By: Claude <noreply@anthropic.com>
  ```

- **å¿…é¡»åŒ…å« Co-author ä¿¡æ¯**ï¼šæ¯ä¸ªæäº¤éƒ½è¦åŒ…å« `Co-authored-by: Claude Code <claude-code@anthropic.com>`

- **ä½¿ç”¨ä¸­æ–‡æäº¤ç±»å‹**ï¼š

  - `feat`: æ–°åŠŸèƒ½
  - `fix`: ä¿®å¤bug
  - `docs`: æ–‡æ¡£æ›´æ–°
  - `style`: ä»£ç æ ¼å¼è°ƒæ•´
  - `refactor`: é‡æ„ä»£ç 
  - `test`: æµ‹è¯•ç›¸å…³
  - `chore`: æ„å»ºå·¥å…·æˆ–è¾…åŠ©å·¥å…·çš„å˜åŠ¨

### å‘½ä»¤æ‰§è¡Œæƒé™

- **å¸¸è§„ Linux å‘½ä»¤å¯ç›´æ¥æ‰§è¡Œ**ï¼š
  - æ–‡ä»¶æ“ä½œï¼š`ls`, `cd`, `cp`, `mv`, `mkdir`, `touch`, `cat`, `less`, `grep`, `find`
  - æ–‡æœ¬å¤„ç†ï¼š`sed`, `awk`, `sort`, `uniq`, `head`, `tail`, `wc`
  - ç³»ç»Ÿä¿¡æ¯ï¼š`ps`, `top`, `df`, `du`, `free`, `whoami`, `pwd`
  - ç½‘ç»œå·¥å…·ï¼š`ping`, `curl`, `wget`
  - å¼€å‘å·¥å…·ï¼š`git status`, `git log`, `git diff`, `npm list`, `pip list`

- **éœ€è¦ç¡®è®¤çš„é‡è¦å‘½ä»¤**ï¼š
  - åˆ é™¤æ“ä½œï¼š`rm -rf`, `rmdir`
  - ç³»ç»Ÿçº§æ“ä½œï¼š`sudo`, `su`, `chmod 777`, `chown`
  - ç½‘ç»œé…ç½®ï¼š`iptables`, `netstat`, `ss`
  - è¿›ç¨‹ç®¡ç†ï¼š`kill`, `killall`, `pkill`
  - åŒ…ç®¡ç†ï¼š`apt install`, `yum install`, `npm install -g`
  - æ•°æ®åº“æ“ä½œï¼š`mysql`, `psql`, `mongo`
  - æœåŠ¡ç®¡ç†ï¼š`systemctl`, `service`

### ä¸ªäººå¼€å‘åå¥½

- **ä»£ç é£æ ¼**ï¼šä½¿ç”¨4ä¸ªç©ºæ ¼ç¼©è¿›ï¼Œä¸ä½¿ç”¨Tab
- **å‡½æ•°å‘½å**ï¼šä½¿ç”¨åŠ¨è¯å¼€å¤´ï¼Œå¦‚ `è·å–ç”¨æˆ·ä¿¡æ¯()`, `å¤„ç†æ–‡æ¡£()`
- **é”™è¯¯å¤„ç†**ï¼šä¼˜å…ˆä½¿ç”¨ try-exceptï¼Œæä¾›ä¸­æ–‡é”™è¯¯ä¿¡æ¯
- **æ—¥å¿—æ ¼å¼**ï¼šä½¿ç”¨ä¸­æ–‡æ—¥å¿—ä¿¡æ¯ï¼Œä¾¿äºè°ƒè¯•
- **æ³¨é‡Šè¯­è¨€**ï¼šæ‰€æœ‰ä»£ç æ³¨é‡Šä½¿ç”¨ä¸­æ–‡
- **å˜é‡å‘½å**ï¼šä½¿ç”¨è‹±æ–‡ï¼Œä½†æ³¨é‡Šè¯´æ˜ä½¿ç”¨ä¸­æ–‡
- **å‡½æ•°è®¾è®¡**ï¼šå•ä¸ªå‡½æ•°ä¸è¶…è¿‡50è¡Œï¼ŒèŒè´£å•ä¸€
- **å¯¼å…¥é¡ºåº**ï¼šæ ‡å‡†åº“ â†’ ç¬¬ä¸‰æ–¹åº“ â†’ æœ¬åœ°æ¨¡å—ï¼Œæ¯ç»„ä¹‹é—´ç©ºä¸€è¡Œ
- **å­—ç¬¦ä¸²å¤„ç†**ï¼šä¼˜å…ˆä½¿ç”¨ f-string æ ¼å¼åŒ–ï¼Œé¿å…ä½¿ç”¨ % æ ¼å¼åŒ–
- **æ–‡ä»¶è·¯å¾„**ï¼šä½¿ç”¨ `pathlib.Path` è€Œä¸æ˜¯ `os.path`
- **é…ç½®ç®¡ç†**ï¼šä½¿ç”¨ `.env` æ–‡ä»¶ç®¡ç†ç¯å¢ƒå˜é‡ï¼Œæ•æ„Ÿä¿¡æ¯ä¸å†™å…¥ä»£ç 
- **ä¾èµ–ç®¡ç†**ï¼šä½¿ç”¨ `requirements.txt` é”å®šç‰ˆæœ¬ï¼Œé‡è¦ä¾èµ–æ·»åŠ ä¸­æ–‡æ³¨é‡Šè¯´æ˜ç”¨é€”

### æ–‡æ¡£å’Œæ³¨é‡Šåå¥½

- **å‡½æ•°æ–‡æ¡£**ï¼šæ‰€æœ‰å‡½æ•°å¿…é¡»æœ‰ä¸­æ–‡docstringï¼Œè¯´æ˜å‚æ•°ã€è¿”å›å€¼ã€å¼‚å¸¸
- **ç±»æ–‡æ¡£**ï¼šç±»çš„ä½œç”¨ã€ä¸»è¦æ–¹æ³•ã€ä½¿ç”¨ç¤ºä¾‹éƒ½ç”¨ä¸­æ–‡æè¿°
- **å¤æ‚é€»è¾‘**ï¼šè¶…è¿‡5è¡Œçš„å¤æ‚é€»è¾‘å¿…é¡»æ·»åŠ ä¸­æ–‡æ³¨é‡Šè§£é‡Š
- **TODOæ ‡è®°**ï¼šä½¿ç”¨ä¸­æ–‡ `# TODO: å¾…å®ç°åŠŸèƒ½æè¿°` æ ¼å¼
- **ä»£ç ç¤ºä¾‹**ï¼šåœ¨æ–‡æ¡£ä¸­æä¾›ä¸­æ–‡æ³¨é‡Šçš„å®Œæ•´ä»£ç ç¤ºä¾‹

### æµ‹è¯•å’Œè´¨é‡ä¿è¯

- **æµ‹è¯•è¦†ç›–**ï¼šé‡è¦å‡½æ•°å¿…é¡»æœ‰å¯¹åº”çš„æµ‹è¯•ç”¨ä¾‹
- **æµ‹è¯•å‘½å**ï¼šæµ‹è¯•å‡½æ•°ä½¿ç”¨ä¸­æ–‡æè¿°ï¼Œå¦‚ `test_ç”¨æˆ·ç™»å½•_æˆåŠŸåœºæ™¯()`
- **æ–­è¨€ä¿¡æ¯**ï¼šæ–­è¨€å¤±è´¥æ—¶æä¾›ä¸­æ–‡é”™è¯¯ä¿¡æ¯
- **æµ‹è¯•æ•°æ®**ï¼šä½¿ç”¨ä¸­æ–‡æµ‹è¯•æ•°æ®ï¼Œæ›´è´´è¿‘å®é™…ä½¿ç”¨åœºæ™¯
- **æ€§èƒ½æµ‹è¯•**ï¼šå…³é”®ç®—æ³•éœ€è¦æ·»åŠ æ€§èƒ½æµ‹è¯•å’ŒåŸºå‡†æµ‹è¯•

### è°ƒè¯•å’Œæ—¥å¿—åå¥½

- **è°ƒè¯•ä¿¡æ¯**ï¼šä½¿ç”¨ä¸­æ–‡debugä¿¡æ¯ï¼Œä¾¿äºå®šä½é—®é¢˜
- **æ—¥å¿—çº§åˆ«**ï¼šå¼€å‘ç¯å¢ƒä½¿ç”¨DEBUGï¼Œç”Ÿäº§ç¯å¢ƒä½¿ç”¨INFO
- **å¼‚å¸¸æ•è·**ï¼šæ•è·å¼‚å¸¸æ—¶è®°å½•ä¸­æ–‡ä¸Šä¸‹æ–‡ä¿¡æ¯
- **æ‰“å°è°ƒè¯•**ï¼šä¸´æ—¶è°ƒè¯•å¯ä»¥ä½¿ç”¨printï¼Œä½†æ­£å¼ä»£ç å¿…é¡»ä½¿ç”¨logging
- **é”™è¯¯è¿½è¸ª**ï¼šé‡è¦é”™è¯¯å¿…é¡»è®°å½•å®Œæ•´çš„ä¸­æ–‡é”™è¯¯å †æ ˆ

### å®‰å…¨å’Œæ€§èƒ½åå¥½

- **è¾“å…¥éªŒè¯**ï¼šæ‰€æœ‰å¤–éƒ¨è¾“å…¥å¿…é¡»éªŒè¯ï¼Œæä¾›ä¸­æ–‡é”™è¯¯æç¤º
- **å¯†ç å¤„ç†**ï¼šä½¿ç”¨bcryptç­‰å®‰å…¨ç®—æ³•ï¼Œä¸æ˜æ–‡å­˜å‚¨
- **APIé™æµ**ï¼šé‡è¦æ¥å£æ·»åŠ é€Ÿç‡é™åˆ¶
- **ç¼“å­˜ç­–ç•¥**ï¼šåˆç†ä½¿ç”¨ç¼“å­˜ï¼Œé¿å…é‡å¤è®¡ç®—
- **èµ„æºæ¸…ç†**ï¼šåŠæ—¶å…³é—­æ–‡ä»¶ã€æ•°æ®åº“è¿æ¥ç­‰èµ„æº

### é¡¹ç›®ç»“æ„åå¥½

- **ç›®å½•å‘½å**ï¼šä½¿ç”¨ä¸­æ–‡æ‹¼éŸ³æˆ–è‹±æ–‡ï¼Œé¿å…ä¸­æ–‡ç›®å½•å
- **æ–‡ä»¶åˆ†ç±»**ï¼šå·¥å…·å‡½æ•°æ”¾åœ¨ `utils/`ï¼Œé…ç½®æ–‡ä»¶æ”¾åœ¨ `config/`
- **æ¨¡å—åˆ’åˆ†**ï¼šæŒ‰åŠŸèƒ½æ¨¡å—åˆ’åˆ†ï¼Œæ¯ä¸ªæ¨¡å—èŒè´£æ¸…æ™°
- **å¸¸é‡å®šä¹‰**ï¼šæ‰€æœ‰é­”æ³•æ•°å­—å’Œå­—ç¬¦ä¸²å®šä¹‰ä¸ºæœ‰æ„ä¹‰çš„å¸¸é‡
- **ç¯å¢ƒéš”ç¦»**ï¼šå¼€å‘ã€æµ‹è¯•ã€ç”Ÿäº§ç¯å¢ƒä¸¥æ ¼éš”ç¦»

## åŸºäºGoè¯­è¨€æ„å»ºç”Ÿäº§çº§LLMç½‘å…³ï¼Œæ”¯æŒå¤šå¹³å°è·¯ç”±ã€å®‰å…¨åŠ å¯†ã€æ™ºèƒ½é™æµå’Œä½æˆæœ¬éƒ¨ç½²

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»å¦‚ä½•ä½¿ç”¨Goè¯­è¨€æ„å»ºä¸€ä¸ªç”Ÿäº§çº§LLMç½‘å…³æœåŠ¡ï¼Œæ”¯æŒOpenAIã€Claudeã€Geminiã€Azure OpenAIç­‰å¤šä¸ªå¹³å°çš„ç»Ÿä¸€æ¥å…¥ã€‚åŒ…å«å®Œæ•´çš„å®‰å…¨æ¶æ„ã€é™æµç­–ç•¥å’Œéƒ¨ç½²æ–¹æ¡ˆã€‚

## 1. æ ¸å¿ƒæ¶æ„è®¾è®¡

### ç»Ÿä¸€APIè®¾è®¡

LLMç½‘å…³çš„æ ¸å¿ƒæ˜¯åˆ›å»ºç»Ÿä¸€çš„è¯·æ±‚å“åº”æ ¼å¼ï¼Œå±è”½å„å¹³å°å·®å¼‚ï¼š

```go
// ç»Ÿä¸€è¯·æ±‚ç»“æ„
type UnifiedRequest struct {
    Model    string    `json:"model"`
    Messages []Message `json:"messages"`
    Parameters Parameters `json:"parameters"`
    Provider string    `json:"provider"`
    Metadata Metadata  `json:"metadata"`
}

type Message struct {
    Role    string `json:"role"`
    Content string `json:"content"`
}

type Parameters struct {
    Temperature      float64 `json:"temperature"`
    MaxTokens       int     `json:"max_tokens"`
    TopP            float64 `json:"top_p"`
    Stream          bool    `json:"stream"`
    FrequencyPenalty float64 `json:"frequency_penalty"`
    PresencePenalty  float64 `json:"presence_penalty"`
}
```

### å¹³å°é€‚é…å™¨å®ç°

æ¯ä¸ªLLMå¹³å°éƒ½éœ€è¦ç‰¹å®šçš„è¯·æ±‚æ ¼å¼è½¬æ¢ï¼š

```go
package providers

import (
    "bytes"
    "encoding/json"
    "net/http"
)

type ProviderAdapter interface {
    Transform(req *UnifiedRequest) ([]byte, error)
    CallAPI(data []byte) (*http.Response, error)
    ParseResponse(resp *http.Response) (*UnifiedResponse, error)
}

// OpenAIé€‚é…å™¨
type OpenAIProvider struct {
    APIKey  string
    BaseURL string
}

func (p *OpenAIProvider) Transform(req *UnifiedRequest) ([]byte, error) {
    openaiReq := map[string]interface{}{
        "model":             req.Model,
        "messages":          req.Messages,
        "temperature":       req.Parameters.Temperature,
        "max_tokens":        req.Parameters.MaxTokens,
        "top_p":            req.Parameters.TopP,
        "stream":           req.Parameters.Stream,
        "frequency_penalty": req.Parameters.FrequencyPenalty,
        "presence_penalty":  req.Parameters.PresencePenalty,
    }
    
    return json.Marshal(openaiReq)
}

// Claudeé€‚é…å™¨
type ClaudeProvider struct {
    APIKey  string
    BaseURL string
}

func (p *ClaudeProvider) Transform(req *UnifiedRequest) ([]byte, error) {
    // æå–ç³»ç»Ÿæ¶ˆæ¯
    var systemMsg string
    var userMessages []Message
    
    for _, msg := range req.Messages {
        if msg.Role == "system" {
            systemMsg = msg.Content
        } else {
            userMessages = append(userMessages, msg)
        }
    }
    
    claudeReq := map[string]interface{}{
        "model":      req.Model,
        "max_tokens": req.Parameters.MaxTokens, // Claudeå¿…éœ€å‚æ•°
        "temperature": req.Parameters.Temperature,
        "top_p":      req.Parameters.TopP,
        "stream":     req.Parameters.Stream,
        "system":     systemMsg,
        "messages":   userMessages,
    }
    
    return json.Marshal(claudeReq)
}
```

### æµå¼å“åº”å¤„ç†

å®ç°SSEæµå¼å“åº”ï¼Œæä¾›å®æ—¶çš„tokenè¾“å‡ºï¼š

```go
package handlers

import (
    "bufio"
    "encoding/json"
    "fmt"
    "net/http"
    "strings"
)

type StreamHandler struct {
    providerManager *ProviderManager
}

func (h *StreamHandler) HandleStream(w http.ResponseWriter, r *http.Request) {
    // è®¾ç½®SSEå¤´éƒ¨
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    w.Header().Set("Access-Control-Allow-Origin", "*")
    
    var req UnifiedRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    provider := h.providerManager.GetProvider(req.Provider)
    resp, err := provider.StreamRequest(&req)
    if err != nil {
        fmt.Fprintf(w, "event: error\ndata: %s\n\n", err.Error())
        return
    }
    defer resp.Body.Close()
    
    scanner := bufio.NewScanner(resp.Body)
    for scanner.Scan() {
        line := scanner.Text()
        if strings.HasPrefix(line, "data: ") {
            data := strings.TrimPrefix(line, "data: ")
            if data == "[DONE]" {
                fmt.Fprint(w, "event: done\ndata: {\"finish_reason\": \"stop\"}\n\n")
                break
            }
            
            // è½¬æ¢ä¸ºç»Ÿä¸€æ ¼å¼
            unified := h.transformStreamChunk(data, req.Provider)
            fmt.Fprintf(w, "event: data\ndata: %s\n\n", unified)
            
            if f, ok := w.(http.Flusher); ok {
                f.Flush()
            }
        }
    }
}
```

## 2. å®‰å…¨ä¸åŠ å¯†å®ç°

### AES-256-GCMå¯†é’¥åŠ å¯†

ä½¿ç”¨Goæ ‡å‡†åº“å®ç°å®‰å…¨çš„APIå¯†é’¥åŠ å¯†ä¼ è¾“ï¼š

```go
package security

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "errors"
)

type KeyManager struct {
    masterKey []byte
}

func NewKeyManager(masterKey string) *KeyManager {
    // ç¡®ä¿å¯†é’¥é•¿åº¦ä¸º32å­—èŠ‚ï¼ˆAES-256ï¼‰
    key := make([]byte, 32)
    copy(key, []byte(masterKey))
    return &KeyManager{masterKey: key}
}

func (km *KeyManager) EncryptAPIKey(apiKey string) (string, error) {
    block, err := aes.NewCipher(km.masterKey)
    if err != nil {
        return "", err
    }
    
    aesGCM, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    // ç”Ÿæˆéšæœºnonce
    nonce := make([]byte, aesGCM.NonceSize())
    if _, err := rand.Read(nonce); err != nil {
        return "", err
    }
    
    // åŠ å¯†
    ciphertext := aesGCM.Seal(nonce, nonce, []byte(apiKey), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (km *KeyManager) DecryptAPIKey(encryptedKey string) (string, error) {
    data, err := base64.StdEncoding.DecodeString(encryptedKey)
    if err != nil {
        return "", err
    }
    
    block, err := aes.NewCipher(km.masterKey)
    if err != nil {
        return "", err
    }
    
    aesGCM, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    nonceSize := aesGCM.NonceSize()
    if len(data) < nonceSize {
        return "", errors.New("å¯†æ–‡é•¿åº¦æ— æ•ˆ")
    }
    
    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }
    
    return string(plaintext), nil
}
```

### é˜²é‡æ”¾æ”»å‡»æœºåˆ¶

åŸºäºRediså®ç°nonceé˜²é‡æ”¾éªŒè¯ï¼š

```go
package security

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "time"
    
    "github.com/go-redis/redis/v8"
    "golang.org/x/net/context"
)

type NonceValidator struct {
    redis      *redis.Client
    expiration time.Duration
}

func NewNonceValidator(redisClient *redis.Client) *NonceValidator {
    return &NonceValidator{
        redis:      redisClient,
        expiration: 5 * time.Minute, // 5åˆ†é’Ÿè¿‡æœŸ
    }
}

func (nv *NonceValidator) GenerateNonce() (string, error) {
    bytes := make([]byte, 16)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    
    timestamp := time.Now().Unix()
    nonce := fmt.Sprintf("%d-%s", timestamp, hex.EncodeToString(bytes))
    return nonce, nil
}

func (nv *NonceValidator) ValidateNonce(nonce string) error {
    ctx := context.Background()
    key := fmt.Sprintf("nonce:%s", nonce)
    
    // æ£€æŸ¥nonceæ˜¯å¦å·²å­˜åœ¨
    exists, err := nv.redis.Exists(ctx, key).Result()
    if err != nil {
        return err
    }
    
    if exists > 0 {
        return errors.New("é‡æ”¾æ”»å‡»ï¼šnonceå·²è¢«ä½¿ç”¨")
    }
    
    // å­˜å‚¨nonceå¹¶è®¾ç½®è¿‡æœŸæ—¶é—´
    err = nv.redis.Set(ctx, key, "used", nv.expiration).Err()
    if err != nil {
        return err
    }
    
    return nil
}
```

### å†…å­˜å®‰å…¨çš„å‡­è¯å¤„ç†

å®ç°å®‰å…¨çš„å†…å­˜æ¸…ç†æœºåˆ¶ï¼š

```go
package security

import (
    "crypto/rand"
    "runtime"
    "unsafe"
)

type SecureString struct {
    data []byte
    size int
}

func NewSecureString(value string) *SecureString {
    data := make([]byte, len(value))
    copy(data, []byte(value))
    
    return &SecureString{
        data: data,
        size: len(data),
    }
}

func (s *SecureString) Clear() {
    if s.data == nil {
        return
    }
    
    // é¦–å…ˆç”¨éšæœºæ•°æ®è¦†ç›–
    rand.Read(s.data)
    
    // ç„¶åç”¨é›¶å€¼è¦†ç›–
    for i := range s.data {
        s.data[i] = 0
    }
    
    // å¼ºåˆ¶åƒåœ¾å›æ”¶
    runtime.GC()
    
    s.data = nil
    s.size = 0
}

func (s *SecureString) String() string {
    if s.data == nil {
        return ""
    }
    return *(*string)(unsafe.Pointer(&s.data))
}

// ä½¿ç”¨ç¤ºä¾‹
func processAPIKey(encryptedKey string, keyManager *KeyManager) error {
    apiKey, err := keyManager.DecryptAPIKey(encryptedKey)
    if err != nil {
        return err
    }
    
    secureKey := NewSecureString(apiKey)
    defer secureKey.Clear() // ç¡®ä¿æ¸…ç†
    
    // ä½¿ç”¨APIå¯†é’¥
    return callProviderAPI(secureKey.String())
}
```

## 3. å¤šå±‚é™æµç­–ç•¥

### Redisåˆ†å¸ƒå¼é™æµ

ä½¿ç”¨Luaè„šæœ¬å®ç°åŸå­æ€§çš„å¤šå±‚é™æµï¼š

```go
package ratelimit

import (
    "context"
    "time"
    
    "github.com/go-redis/redis/v8"
)

type RateLimiter struct {
    redis *redis.Client
    luaScript string
}

func NewRateLimiter(redisClient *redis.Client) *RateLimiter {
    script := `
    local global_key = KEYS[1]
    local user_key = KEYS[2]
    local ip_key = KEYS[3]
    
    local global_limit = tonumber(ARGV[1])
    local user_limit = tonumber(ARGV[2])
    local ip_limit = tonumber(ARGV[3])
    local window = tonumber(ARGV[4])
    
    -- æ£€æŸ¥å…¨å±€é™æµ
    local global_count = tonumber(redis.call('GET', global_key) or 0)
    if global_count >= global_limit then
        return {0, "global_limit_exceeded", global_limit - global_count}
    end
    
    -- æ£€æŸ¥ç”¨æˆ·é™æµ
    local user_count = tonumber(redis.call('GET', user_key) or 0)
    if user_count >= user_limit then
        return {0, "user_limit_exceeded", user_limit - user_count}
    end
    
    -- æ£€æŸ¥IPé™æµ
    local ip_count = tonumber(redis.call('GET', ip_key) or 0)
    if ip_count >= ip_limit then
        return {0, "ip_limit_exceeded", ip_limit - ip_count}
    end
    
    -- å¢åŠ è®¡æ•°å™¨
    redis.call('INCR', global_key)
    redis.call('EXPIRE', global_key, window)
    redis.call('INCR', user_key)
    redis.call('EXPIRE', user_key, window)
    redis.call('INCR', ip_key)
    redis.call('EXPIRE', ip_key, window)
    
    return {1, "allowed", math.min(
        global_limit - global_count - 1,
        user_limit - user_count - 1,
        ip_limit - ip_count - 1
    )}
    `
    
    return &RateLimiter{
        redis: redisClient,
        luaScript: script,
    }
}

type LimitResult struct {
    Allowed   bool   `json:"allowed"`
    Reason    string `json:"reason"`
    Remaining int    `json:"remaining"`
}

func (rl *RateLimiter) CheckLimit(ctx context.Context, userID, ip string) (*LimitResult, error) {
    now := time.Now()
    window := 3600 // 1å°æ—¶çª—å£
    
    keys := []string{
        fmt.Sprintf("global:%d", now.Hour()),
        fmt.Sprintf("user:%s:%d", userID, now.Hour()),
        fmt.Sprintf("ip:%s:%d", ip, now.Hour()),
    }
    
    args := []interface{}{
        1000, // å…¨å±€é™åˆ¶ï¼šæ¯å°æ—¶1000æ¬¡
        100,  // ç”¨æˆ·é™åˆ¶ï¼šæ¯å°æ—¶100æ¬¡
        50,   // IPé™åˆ¶ï¼šæ¯å°æ—¶50æ¬¡
        window,
    }
    
    result, err := rl.redis.Eval(ctx, rl.luaScript, keys, args...).Result()
    if err != nil {
        return nil, err
    }
    
    res := result.([]interface{})
    allowed := res[0].(int64) == 1
    reason := res[1].(string)
    remaining := int(res[2].(int64))
    
    return &LimitResult{
        Allowed:   allowed,
        Reason:    reason,
        Remaining: remaining,
    }, nil
}
```

### åŠ¨æ€é™æµè°ƒæ•´

æ ¹æ®ä¸Šæ¸¸APIå“åº”æƒ…å†µåŠ¨æ€è°ƒæ•´é™æµç­–ç•¥ï¼š

```go
package ratelimit

import (
    "sync"
    "time"
)

type AdaptiveRateLimiter struct {
    mu           sync.RWMutex
    baseLimit    int
    currentLimit int
    metrics      *MetricsCollector
}

type MetricsCollector struct {
    totalRequests int64
    errorCount    int64
    totalLatency  time.Duration
    window        time.Duration
}

func NewAdaptiveRateLimiter(baseLimit int) *AdaptiveRateLimiter {
    return &AdaptiveRateLimiter{
        baseLimit:    baseLimit,
        currentLimit: baseLimit,
        metrics:      &MetricsCollector{window: time.Minute},
    }
}

func (arl *AdaptiveRateLimiter) AdjustLimits() {
    arl.mu.Lock()
    defer arl.mu.Unlock()
    
    if arl.metrics.totalRequests == 0 {
        return
    }
    
    errorRate := float64(arl.metrics.errorCount) / float64(arl.metrics.totalRequests)
    avgLatency := arl.metrics.totalLatency / time.Duration(arl.metrics.totalRequests)
    
    adjustmentFactor := 1.0
    
    // æ ¹æ®é”™è¯¯ç‡è°ƒæ•´
    switch {
    case errorRate > 0.1: // é”™è¯¯ç‡è¶…è¿‡10%
        adjustmentFactor *= 0.5
    case errorRate > 0.05: // é”™è¯¯ç‡è¶…è¿‡5%
        adjustmentFactor *= 0.7
    case errorRate < 0.01: // é”™è¯¯ç‡ä½äº1%
        adjustmentFactor *= 1.2
    }
    
    // æ ¹æ®å»¶è¿Ÿè°ƒæ•´
    switch {
    case avgLatency > 5*time.Second:
        adjustmentFactor *= 0.6
    case avgLatency > 2*time.Second:
        adjustmentFactor *= 0.8
    case avgLatency < 500*time.Millisecond:
        adjustmentFactor *= 1.1
    }
    
    // åº”ç”¨è°ƒæ•´ï¼Œè®¾ç½®è¾¹ç•Œ
    newLimit := int(float64(arl.baseLimit) * adjustmentFactor)
    if newLimit < 10 {
        newLimit = 10
    } else if newLimit > arl.baseLimit*2 {
        newLimit = arl.baseLimit * 2
    }
    
    arl.currentLimit = newLimit
    
    // é‡ç½®æŒ‡æ ‡
    arl.metrics.totalRequests = 0
    arl.metrics.errorCount = 0
    arl.metrics.totalLatency = 0
}

func (arl *AdaptiveRateLimiter) RecordRequest(latency time.Duration, isError bool) {
    arl.mu.Lock()
    defer arl.mu.Unlock()
    
    arl.metrics.totalRequests++
    arl.metrics.totalLatency += latency
    if isError {
        arl.metrics.errorCount++
    }
}
```

## 4. ä½æˆæœ¬éƒ¨ç½²æ–¹æ¡ˆ

### æ¨èéƒ¨ç½²æ¶æ„

**å¼€å‘æµ‹è¯•é˜¶æ®µï¼ˆå…è´¹ï¼‰**
- å¹³å°ï¼šOracle Cloudæ°¸ä¹…å…è´¹å±‚
- é…ç½®ï¼šARMå®ä¾‹ 4æ ¸24GBï¼ˆå¯åˆ†å‰²æˆå¤šä¸ªå®ä¾‹ï¼‰
- æˆæœ¬ï¼š$0/æœˆ

**å°è§„æ¨¡ç”Ÿäº§ï¼ˆæ¨èï¼‰**
- å¹³å°ï¼šHetzner VPS
- é…ç½®ï¼šCX31 (2vCPU, 8GB RAM, 20TBæµé‡)
- æˆæœ¬ï¼šâ‚¬16.64/æœˆ (~$18)

**å¤§è§„æ¨¡ç”Ÿäº§**
- æ¶æ„ï¼šHetzner + Cloudflare Workers
- æˆæœ¬ï¼šçº¦$30-50/æœˆï¼ˆåŒ…å«CDNå’Œè¾¹ç¼˜ç¼“å­˜ï¼‰

### Dockeréƒ¨ç½²é…ç½®

```dockerfile
# å¤šé˜¶æ®µæ„å»ºï¼Œæœ€å°åŒ–é•œåƒå¤§å°
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -ldflags '-w -s' -o gateway ./cmd/server

# è¿è¡Œæ—¶é•œåƒ
FROM alpine:latest
RUN apk --no-cache add ca-certificates tzdata
WORKDIR /root/

COPY --from=builder /app/gateway .
COPY --from=builder /app/configs ./configs

EXPOSE 8080
CMD ["./gateway"]
```

### Docker Composeé…ç½®

```yaml
version: '3.8'

services:
  gateway:
    build: .
    ports:
      - "8080:8080"
    environment:
      - REDIS_URL=redis://redis:6379
      - MASTER_KEY=${MASTER_KEY}
      - LOG_LEVEL=info
    depends_on:
      - redis
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    restart: unless-stopped

  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./configs/prometheus.yml:/etc/prometheus/prometheus.yml
    restart: unless-stopped

volumes:
  redis_data:
```

## 5. Goæ¡†æ¶é€‰æ‹©ä¸æ€§èƒ½ä¼˜åŒ–

### æ¡†æ¶å¯¹æ¯”

**Fiberï¼ˆæ¨èï¼‰**
- æ€§èƒ½ï¼šå•æ ¸5000+ RPS
- ç‰¹ç‚¹ï¼šç±»Express APIï¼Œé›¶å†…å­˜åˆ†é…
- é€‚ç”¨ï¼šé«˜æ€§èƒ½ç½‘å…³æœåŠ¡

**Gin**
- æ€§èƒ½ï¼šå•æ ¸3000+ RPS  
- ç‰¹ç‚¹ï¼šç”Ÿæ€ä¸°å¯Œï¼Œä¸­é—´ä»¶å¤š
- é€‚ç”¨ï¼šå¿«é€Ÿå¼€å‘

### é«˜æ€§èƒ½æœåŠ¡å™¨å®ç°

```go
package main

import (
    "log"
    "runtime"
    
    "github.com/gofiber/fiber/v2"
    "github.com/gofiber/fiber/v2/middleware/cors"
    "github.com/gofiber/fiber/v2/middleware/logger"
    "github.com/gofiber/fiber/v2/middleware/recover"
)

func main() {
    // è®¾ç½®ä½¿ç”¨æ‰€æœ‰CPUæ ¸å¿ƒ
    runtime.GOMAXPROCS(runtime.NumCPU())
    
    app := fiber.New(fiber.Config{
        Prefork:          true,  // å¤šè¿›ç¨‹æ¨¡å¼
        CaseSensitive:    true,
        StrictRouting:    true,
        ServerHeader:     "ChatNexus/1.0",
        AppName:          "ChatNexus Gateway",
        BodyLimit:        10 * 1024 * 1024, // 10MB
        ReadTimeout:      time.Second * 30,
        WriteTimeout:     time.Second * 30,
        IdleTimeout:      time.Second * 120,
    })
    
    // ä¸­é—´ä»¶
    app.Use(recover.New())
    app.Use(logger.New(logger.Config{
        Format: "${time} ${status} ${latency} ${method} ${path}\n",
    }))
    app.Use(cors.New())
    
    // è·¯ç”±
    api := app.Group("/v1")
    api.Post("/chat/completions", handleChatCompletion)
    api.Get("/models", handleListModels)
    api.Get("/health", handleHealth)
    
    log.Fatal(app.Listen(":8080"))
}

func handleChatCompletion(c *fiber.Ctx) error {
    // è§£æè¯·æ±‚
    var req UnifiedRequest
    if err := c.BodyParser(&req); err != nil {
        return c.Status(400).JSON(fiber.Map{
            "error": "è¯·æ±‚æ ¼å¼é”™è¯¯: " + err.Error(),
        })
    }
    
    // éªŒè¯å’Œé™æµ
    if err := validateAndRateLimit(c, &req); err != nil {
        return c.Status(429).JSON(fiber.Map{
            "error": err.Error(),
        })
    }
    
    // è·¯ç”±åˆ°å¯¹åº”æä¾›å•†
    provider := getProvider(req.Provider)
    response, err := provider.Process(&req)
    if err != nil {
        return c.Status(500).JSON(fiber.Map{
            "error": "å¤„ç†è¯·æ±‚å¤±è´¥: " + err.Error(),
        })
    }
    
    return c.JSON(response)
}
```

## 6. ç”Ÿäº§ç¯å¢ƒè€ƒè™‘

### è´Ÿè½½å‡è¡¡ä¸æ•…éšœè½¬ç§»

```go
package loadbalancer

import (
    "errors"
    "sort"
    "sync"
    "time"
)

type LoadBalancer struct {
    providers    []Provider
    healthStatus map[string]*HealthInfo
    mu           sync.RWMutex
}

type HealthInfo struct {
    IsHealthy     bool
    LastCheck     time.Time
    AverageLatency time.Duration
    ErrorRate     float64
}

func (lb *LoadBalancer) SelectProvider(request *UnifiedRequest) (Provider, error) {
    lb.mu.RLock()
    defer lb.mu.RUnlock()
    
    var healthyProviders []Provider
    for _, provider := range lb.providers {
        if health, exists := lb.healthStatus[provider.Name()]; exists && health.IsHealthy {
            healthyProviders = append(healthyProviders, provider)
        }
    }
    
    if len(healthyProviders) == 0 {
        return nil, errors.New("æ²¡æœ‰å¯ç”¨çš„å¥åº·æä¾›å•†")
    }
    
    // æŒ‰å»¶è¿Ÿæ’åºï¼Œé€‰æ‹©æœ€å¿«çš„
    sort.Slice(healthyProviders, func(i, j int) bool {
        latencyI := lb.healthStatus[healthyProviders[i].Name()].AverageLatency
        latencyJ := lb.healthStatus[healthyProviders[j].Name()].AverageLatency
        return latencyI < latencyJ
    })
    
    return healthyProviders[0], nil
}

func (lb *LoadBalancer) StartHealthCheck() {
    ticker := time.NewTicker(30 * time.Second)
    go func() {
        for range ticker.C {
            lb.performHealthChecks()
        }
    }()
}

func (lb *LoadBalancer) performHealthChecks() {
    for _, provider := range lb.providers {
        go func(p Provider) {
            start := time.Now()
            err := p.HealthCheck()
            latency := time.Since(start)
            
            lb.mu.Lock()
            if lb.healthStatus[p.Name()] == nil {
                lb.healthStatus[p.Name()] = &HealthInfo{}
            }
            
            health := lb.healthStatus[p.Name()]
            health.IsHealthy = err == nil
            health.LastCheck = time.Now()
            health.AverageLatency = (health.AverageLatency + latency) / 2
            lb.mu.Unlock()
        }(provider)
    }
}
```

### ç›‘æ§æŒ‡æ ‡æ”¶é›†

```go
package metrics

import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    RequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "llm_requests_total",
            Help: "LLMè¯·æ±‚æ€»æ•°",
        },
        []string{"provider", "model", "status"},
    )
    
    RequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "llm_request_duration_seconds",
            Help: "LLMè¯·æ±‚è€—æ—¶ï¼ˆç§’ï¼‰",
            Buckets: []float64{0.1, 0.5, 1, 2.5, 5, 10, 30},
        },
        []string{"provider", "model"},
    )
    
    TokensProcessed = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "llm_tokens_processed_total", 
            Help: "å¤„ç†çš„tokenæ€»æ•°",
        },
        []string{"provider", "model", "type"},
    )
    
    CostTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "llm_cost_usd_total",
            Help: "LLMè°ƒç”¨æ€»æˆæœ¬ï¼ˆç¾å…ƒï¼‰",
        },
        []string{"provider", "model"},
    )
)

// è®°å½•è¯·æ±‚æŒ‡æ ‡
func RecordRequest(provider, model, status string, duration time.Duration, inputTokens, outputTokens int, cost float64) {
    RequestsTotal.WithLabelValues(provider, model, status).Inc()
    RequestDuration.WithLabelValues(provider, model).Observe(duration.Seconds())
    TokensProcessed.WithLabelValues(provider, model, "input").Add(float64(inputTokens))
    TokensProcessed.WithLabelValues(provider, model, "output").Add(float64(outputTokens))
    CostTotal.WithLabelValues(provider, model).Add(cost)
}
```

### é…ç½®ç®¡ç†

```go
package config

import (
    "os"
    "strconv"
    "time"
)

type Config struct {
    Server   ServerConfig   `yaml:"server"`
    Redis    RedisConfig    `yaml:"redis"`
    Security SecurityConfig `yaml:"security"`
    Providers []ProviderConfig `yaml:"providers"`
}

type ServerConfig struct {
    Port         int           `yaml:"port"`
    ReadTimeout  time.Duration `yaml:"read_timeout"`
    WriteTimeout time.Duration `yaml:"write_timeout"`
    IdleTimeout  time.Duration `yaml:"idle_timeout"`
}

func LoadConfig() *Config {
    return &Config{
        Server: ServerConfig{
            Port:         getEnvInt("PORT", 8080),
            ReadTimeout:  time.Second * 30,
            WriteTimeout: time.Second * 30,
            IdleTimeout:  time.Second * 120,
        },
        Redis: RedisConfig{
            URL: getEnv("REDIS_URL", "redis://localhost:6379"),
        },
        Security: SecurityConfig{
            MasterKey: getEnv("MASTER_KEY", "your-secret-key"),
        },
    }
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}
```

## é¡¹ç›®ç»“æ„å»ºè®®

```
ChatNexus/
â”œâ”€â”€ cmd/
â”‚   â””â”€â”€ server/
â”‚       â””â”€â”€ main.go              # æœåŠ¡å…¥å£
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ handlers/                # HTTPå¤„ç†å™¨
â”‚   â”‚   â”œâ”€â”€ chat.go
â”‚   â”‚   â”œâ”€â”€ models.go
â”‚   â”‚   â””â”€â”€ health.go
â”‚   â”œâ”€â”€ providers/               # LLMæä¾›å•†
â”‚   â”‚   â”œâ”€â”€ openai.go
â”‚   â”‚   â”œâ”€â”€ claude.go
â”‚   â”‚   â”œâ”€â”€ gemini.go
â”‚   â”‚   â””â”€â”€ base.go
â”‚   â”œâ”€â”€ security/                # å®‰å…¨æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ encryption.go
â”‚   â”‚   â””â”€â”€ nonce.go
â”‚   â”œâ”€â”€ ratelimit/              # é™æµæ¨¡å—
â”‚   â”‚   â””â”€â”€ limiter.go
â”‚   â””â”€â”€ metrics/                # ç›‘æ§æŒ‡æ ‡
â”‚       â””â”€â”€ collector.go
â”œâ”€â”€ pkg/
â”‚   â””â”€â”€ types/                  # å…¬å…±ç±»å‹å®šä¹‰
â”‚       â””â”€â”€ requests.go
â”œâ”€â”€ configs/
â”‚   â”œâ”€â”€ config.yaml
â”‚   â””â”€â”€ prometheus.yml
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ go.mod
â””â”€â”€ README.md
```

## æ€»ç»“

æœ¬æŒ‡å—æä¾›äº†æ„å»ºç”Ÿäº§çº§LLMç½‘å…³çš„å®Œæ•´Goè¯­è¨€å®ç°æ–¹æ¡ˆï¼Œä¸»è¦ç‰¹ç‚¹ï¼š

**æŠ€æœ¯æ ˆé€‰æ‹©**
- Go + Fiberæ¡†æ¶ï¼ˆ5000+ RPSæ€§èƒ½ï¼‰
- Redisåˆ†å¸ƒå¼ç¼“å­˜å’Œé™æµ
- AES-256-GCMåŠ å¯†ä¼ è¾“
- Prometheusç›‘æ§

**éƒ¨ç½²å»ºè®®**
- å¼€å‘ï¼šOracle Cloudå…è´¹å±‚
- ç”Ÿäº§ï¼šHetzner VPSï¼ˆæœ€ä½³æ€§ä»·æ¯”ï¼‰
- æ‰©å±•ï¼šCloudflare Workersè¾¹ç¼˜ç¼“å­˜

**æ ¸å¿ƒç‰¹æ€§**
- ç»Ÿä¸€å¤šå¹³å°APIæ¥å£
- å¤šå±‚è‡ªé€‚åº”é™æµ
- ç«¯åˆ°ç«¯å®‰å…¨åŠ å¯†
- å®æ—¶ç›‘æ§å‘Šè­¦

è¿™ä¸ªæ¶æ„å¯ä»¥æ”¯æŒåƒä¸‡çº§è¯·æ±‚ï¼ŒåŒæ—¶ä¿æŒè¾ƒä½çš„è¿è¥æˆæœ¬å’Œé«˜å¯ç”¨æ€§ã€‚